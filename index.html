
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>adapter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lamboktulussimamora/gra/adapter/adapter.go (100.0%)</option>
				
				<option value="file1">github.com/lamboktulussimamora/gra/context/context.go (100.0%)</option>
				
				<option value="file2">github.com/lamboktulussimamora/gra/gra.go (100.0%)</option>
				
				<option value="file3">github.com/lamboktulussimamora/gra/logger/logger.go (93.9%)</option>
				
				<option value="file4">github.com/lamboktulussimamora/gra/middleware/middleware.go (100.0%)</option>
				
				<option value="file5">github.com/lamboktulussimamora/gra/router/router.go (95.7%)</option>
				
				<option value="file6">github.com/lamboktulussimamora/gra/validator/validator.go (98.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package adapter provides adapters for different HTTP handler types.
package adapter

import (
        "net/http"

        "github.com/lamboktulussimamora/gra/context"
        "github.com/lamboktulussimamora/gra/router"
)

// HTTPHandler converts a router.HandlerFunc to an http.HandlerFunc
func HTTPHandler(f router.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := context.New(w, r)
                f(ctx)
        }</span>
}

// HandlerAdapter wraps a router.HandlerFunc to implement http.Handler
type HandlerAdapter router.HandlerFunc

// ServeHTTP implements the http.Handler interface for HandlerAdapter
func (f HandlerAdapter) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := context.New(w, r)
        router.HandlerFunc(f)(ctx)
}</span>

// AsHTTPHandler converts a router.HandlerFunc to http.Handler
func AsHTTPHandler(f router.HandlerFunc) http.Handler <span class="cov8" title="1">{
        return HandlerAdapter(f)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package context provides the Context type for handling HTTP requests and responses.
package context

import (
        "context"
        "encoding/json"
        "io"
        "log"
        "net/http"
)

// APIResponse is a standardized response structure
type APIResponse struct {
        Status  string `json:"status"`          // "success" or "error"
        Message string `json:"message"`         // Human-readable message
        Data    any    `json:"data,omitempty"`  // Optional data payload
        Error   string `json:"error,omitempty"` // Error message if status is "error"
}

// Context wraps the HTTP request and response
// It provides helper methods for handling requests and responses
type Context struct {
        Writer  http.ResponseWriter
        Request *http.Request
        Params  map[string]string // For route parameters
        ctx     context.Context
}

// New creates a new Context
func New(w http.ResponseWriter, r *http.Request) *Context <span class="cov8" title="1">{
        return &amp;Context{
                Writer:  w,
                Request: r,
                Params:  make(map[string]string),
                ctx:     r.Context(),
        }
}</span>

// Status sets the HTTP status code
func (c *Context) Status(code int) *Context <span class="cov8" title="1">{
        c.Writer.WriteHeader(code)
        return c
}</span>

// JSON sends a JSON response
func (c *Context) JSON(status int, obj any) <span class="cov8" title="1">{
        c.Writer.Header().Set("Content-Type", "application/json")
        c.Writer.WriteHeader(status)
        if err := json.NewEncoder(c.Writer).Encode(obj); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error encoding JSON: %v", err)
        }</span>
}

// BindJSON binds JSON request body to a struct
func (c *Context) BindJSON(obj any) error <span class="cov8" title="1">{
        body, err := io.ReadAll(c.Request.Body)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer c.Request.Body.Close()

        return json.Unmarshal(body, obj)</span>
}

// Success sends a success response
func (c *Context) Success(status int, message string, data any) <span class="cov8" title="1">{
        c.JSON(status, APIResponse{
                Status:  "success",
                Message: message,
                Data:    data,
        })
}</span>

// Error sends an error response
func (c *Context) Error(status int, errorMsg string) <span class="cov8" title="1">{
        c.JSON(status, APIResponse{
                Status: "error",
                Error:  errorMsg,
        })
}</span>

// GetParam gets a path parameter value
func (c *Context) GetParam(key string) string <span class="cov8" title="1">{
        return c.Params[key]
}</span>

// GetQuery gets a query parameter value
func (c *Context) GetQuery(key string) string <span class="cov8" title="1">{
        return c.Request.URL.Query().Get(key)
}</span>

// JSONData sends a JSON response with just the data without wrapping it in APIResponse.
// Use this when you want to return only the data payload directly, for example:
// - When you need to conform to a specific API format expected by a client
// - When you want to return an array directly in the response body
// - When integrating with systems that expect a simple JSON structure
func (c *Context) JSONData(status int, data any) <span class="cov8" title="1">{
        c.Writer.Header().Set("Content-Type", "application/json")
        c.Writer.WriteHeader(status)
        if err := json.NewEncoder(c.Writer).Encode(data); err != nil </span><span class="cov8" title="1">{
                log.Printf("Error encoding JSON: %v", err)
        }</span>
}

// WithValue adds a value to the request context
func (c *Context) WithValue(key, value any) *Context <span class="cov8" title="1">{
        c.ctx = context.WithValue(c.ctx, key, value)
        c.Request = c.Request.WithContext(c.ctx)
        return c
}</span>

// Value gets a value from the request context
func (c *Context) Value(key any) any <span class="cov8" title="1">{
        return c.ctx.Value(key)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package gra provides a lightweight HTTP framework for building web applications.
//
// GRA is a minimalist web framework inspired by Gin, designed for building
// clean architecture applications in Go. It includes a Context object for handling
// requests and responses, a Router for URL routing, middleware support, and validation
// utilities.
package gra

import (
        "net/http"

        "github.com/lamboktulussimamora/gra/context"
        "github.com/lamboktulussimamora/gra/router"
)

// Version is the current version of the framework
const Version = "1.0.3"

// New creates a new router with default configuration
func New() *router.Router <span class="cov8" title="1">{
        return router.New()
}</span>

// Run starts the HTTP server with the given router
func Run(addr string, r *router.Router) error <span class="cov8" title="1">{
        return http.ListenAndServe(addr, r)
}</span>

// Context is an alias for context.Context
type Context = context.Context

// HandlerFunc is an alias for router.HandlerFunc
type HandlerFunc = router.HandlerFunc

// Middleware is an alias for router.Middleware
type Middleware = router.Middleware
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package logger provides logging functionality.
package logger

import (
        "fmt"
        "log"
        "os"
        "sync"
        "time"
)

// LogLevel represents the level of logging
type LogLevel int

const (
        // DEBUG level for detailed debugging
        DEBUG LogLevel = iota
        // INFO level for general information
        INFO
        // WARN level for warnings
        WARN
        // ERROR level for errors
        ERROR
        // FATAL level for fatal errors
        FATAL
)

// Logger provides logging functionality
type Logger struct {
        level  LogLevel
        prefix string
        logger *log.Logger
}

var (
        defaultLogger *Logger
        once          sync.Once
        osExit        = os.Exit // Variable for overriding os.Exit in tests
)

// Get returns the default logger
func Get() *Logger <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                defaultLogger = &amp;Logger{
                        level:  INFO,
                        prefix: "",
                        logger: log.New(os.Stdout, "", log.LstdFlags),
                }
        }</span>)
        <span class="cov8" title="1">return defaultLogger</span>
}

// New creates a new logger with the specified prefix
func New(prefix string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                level:  INFO,
                prefix: prefix,
                logger: log.New(os.Stdout, "", log.LstdFlags),
        }
}</span>

// SetLevel sets the log level
func (l *Logger) SetLevel(level LogLevel) <span class="cov8" title="1">{
        l.level = level
}</span>

// SetPrefix sets the log prefix
func (l *Logger) SetPrefix(prefix string) <span class="cov0" title="0">{
        l.prefix = prefix
}</span>

// log logs a message at the specified level
func (l *Logger) log(level LogLevel, format string, args ...any) <span class="cov8" title="1">{
        if level &lt; l.level </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var levelStr string
        switch level </span>{
        case DEBUG:<span class="cov8" title="1">
                levelStr = "DEBUG"</span>
        case INFO:<span class="cov8" title="1">
                levelStr = "INFO"</span>
        case WARN:<span class="cov8" title="1">
                levelStr = "WARN"</span>
        case ERROR:<span class="cov8" title="1">
                levelStr = "ERROR"</span>
        case FATAL:<span class="cov8" title="1">
                levelStr = "FATAL"</span>
        }

        <span class="cov8" title="1">prefix := ""
        if l.prefix != "" </span><span class="cov8" title="1">{
                prefix = "[" + l.prefix + "] "
        }</span>

        <span class="cov8" title="1">timestamp := time.Now().Format("2006/01/02 15:04:05")
        message := fmt.Sprintf(format, args...)
        l.logger.Printf("%s %s%s: %s", timestamp, prefix, levelStr, message)

        if level == FATAL </span><span class="cov8" title="1">{
                osExit(1)
        }</span>
}

// Debug logs a message at DEBUG level
func (l *Logger) Debug(args ...any) <span class="cov8" title="1">{
        l.log(DEBUG, "%s", fmt.Sprint(args...))
}</span>

// Debugf logs a formatted message at DEBUG level
func (l *Logger) Debugf(format string, args ...any) <span class="cov8" title="1">{
        l.log(DEBUG, format, args...)
}</span>

// Info logs a message at INFO level
func (l *Logger) Info(args ...any) <span class="cov8" title="1">{
        l.log(INFO, "%s", fmt.Sprint(args...))
}</span>

// Infof logs a formatted message at INFO level
func (l *Logger) Infof(format string, args ...any) <span class="cov8" title="1">{
        l.log(INFO, format, args...)
}</span>

// Warn logs a message at WARN level
func (l *Logger) Warn(args ...any) <span class="cov8" title="1">{
        l.log(WARN, "%s", fmt.Sprint(args...))
}</span>

// Warnf logs a formatted message at WARN level
func (l *Logger) Warnf(format string, args ...any) <span class="cov8" title="1">{
        l.log(WARN, format, args...)
}</span>

// Error logs a message at ERROR level
func (l *Logger) Error(args ...any) <span class="cov8" title="1">{
        l.log(ERROR, "%s", fmt.Sprint(args...))
}</span>

// Errorf logs a formatted message at ERROR level
func (l *Logger) Errorf(format string, args ...any) <span class="cov8" title="1">{
        l.log(ERROR, format, args...)
}</span>

// Fatal logs a message at FATAL level and exits
func (l *Logger) Fatal(args ...any) <span class="cov8" title="1">{
        l.log(FATAL, "%s", fmt.Sprint(args...))
}</span>

// Fatalf logs a formatted message at FATAL level and exits
func (l *Logger) Fatalf(format string, args ...any) <span class="cov8" title="1">{
        l.log(FATAL, format, args...)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package middleware provides common HTTP middleware components.
package middleware

import (
        "net/http"
        "strings"

        "github.com/lamboktulussimamora/gra/context"
        "github.com/lamboktulussimamora/gra/logger"
        "github.com/lamboktulussimamora/gra/router"
)

// JWTAuthenticator defines an interface for JWT token validation
type JWTAuthenticator interface {
        ValidateToken(tokenString string) (any, error)
}

// Auth authenticates requests using JWT
func Auth(jwtService JWTAuthenticator, claimsKey string) router.Middleware <span class="cov8" title="1">{
        return func(next router.HandlerFunc) router.HandlerFunc </span><span class="cov8" title="1">{
                return func(c *context.Context) </span><span class="cov8" title="1">{
                        // Get the Authorization header
                        authHeader := c.Request.Header.Get("Authorization")
                        if authHeader == "" </span><span class="cov8" title="1">{
                                c.Error(http.StatusUnauthorized, "Authorization header is required")
                                return
                        }</span>

                        // Check if the header has the correct format (Bearer &lt;token&gt;)
                        <span class="cov8" title="1">parts := strings.Split(authHeader, " ")
                        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov8" title="1">{
                                c.Error(http.StatusUnauthorized, "Authorization header format must be Bearer &lt;token&gt;")
                                return
                        }</span>

                        // Extract the token
                        <span class="cov8" title="1">tokenString := parts[1]

                        // Validate the token
                        claims, err := jwtService.ValidateToken(tokenString)
                        if err != nil </span><span class="cov8" title="1">{
                                c.Error(http.StatusUnauthorized, "Invalid token")
                                return
                        }</span>

                        // Add claims to context
                        <span class="cov8" title="1">c.WithValue(claimsKey, claims)

                        // Call the next handler
                        next(c)</span>
                }
        }
}

// Logger logs incoming requests
func Logger() router.Middleware <span class="cov8" title="1">{
        return func(next router.HandlerFunc) router.HandlerFunc </span><span class="cov8" title="1">{
                return func(c *context.Context) </span><span class="cov8" title="1">{
                        // Log the request
                        method := c.Request.Method
                        path := c.Request.URL.Path

                        // Log before handling
                        log := logger.Get()
                        log.Infof("Request: %s %s", method, path)

                        // Call the next handler
                        next(c)

                        // Log after handling
                        log.Infof("Completed: %s %s", method, path)
                }</span>
        }
}

// Recovery recovers from panics
func Recovery() router.Middleware <span class="cov8" title="1">{
        return func(next router.HandlerFunc) router.HandlerFunc </span><span class="cov8" title="1">{
                return func(c *context.Context) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if err := recover(); err != nil </span><span class="cov8" title="1">{
                                        log := logger.Get()
                                        log.Errorf("Panic recovered: %v", err)
                                        c.Error(http.StatusInternalServerError, "Internal server error")
                                }</span>
                        }()

                        <span class="cov8" title="1">next(c)</span>
                }
        }
}

// CORS handles Cross-Origin Resource Sharing
func CORS(allowOrigin string) router.Middleware <span class="cov8" title="1">{
        return func(next router.HandlerFunc) router.HandlerFunc </span><span class="cov8" title="1">{
                return func(c *context.Context) </span><span class="cov8" title="1">{
                        c.Writer.Header().Set("Access-Control-Allow-Origin", allowOrigin)
                        c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                        c.Writer.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")

                        // Handle preflight requests
                        if c.Request.Method == http.MethodOptions </span><span class="cov8" title="1">{
                                c.Writer.WriteHeader(http.StatusOK)
                                return
                        }</span>

                        <span class="cov8" title="1">next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package router provides HTTP routing capabilities.
package router

import (
        "net/http"
        "strings"

        "github.com/lamboktulussimamora/gra/context"
)

// HandlerFunc defines a function that processes requests using Context
type HandlerFunc func(*context.Context)

// Middleware defines a function that runs before a request handler
type Middleware func(HandlerFunc) HandlerFunc

// Route represents a URL route and its handler
type Route struct {
        Method  string
        Path    string
        Handler HandlerFunc
}

// Router handles HTTP requests and routes them to the appropriate handler
type Router struct {
        routes           []Route
        middlewares      []Middleware
        notFound         HandlerFunc
        methodNotAllowed HandlerFunc
}

// New creates a new router
func New() *Router <span class="cov8" title="1">{
        return &amp;Router{
                routes:      []Route{},
                middlewares: []Middleware{},
                notFound: func(c *context.Context) </span><span class="cov0" title="0">{
                        c.Error(http.StatusNotFound, "Not found")
                }</span>,
                methodNotAllowed: func(c *context.Context) <span class="cov0" title="0">{
                        c.Error(http.StatusMethodNotAllowed, "Method not allowed")
                }</span>,
        }
}

// Use adds middleware to the router
func (r *Router) Use(middleware ...Middleware) <span class="cov8" title="1">{
        r.middlewares = append(r.middlewares, middleware...)
}</span>

// Handle registers a new route with the router
func (r *Router) Handle(method, path string, handler HandlerFunc) <span class="cov8" title="1">{
        r.routes = append(r.routes, Route{
                Method:  method,
                Path:    path,
                Handler: handler,
        })
}</span>

// GET registers a new GET route
func (r *Router) GET(path string, handler HandlerFunc) <span class="cov8" title="1">{
        r.Handle(http.MethodGet, path, handler)
}</span>

// POST registers a new POST route
func (r *Router) POST(path string, handler HandlerFunc) <span class="cov8" title="1">{
        r.Handle(http.MethodPost, path, handler)
}</span>

// PUT registers a new PUT route
func (r *Router) PUT(path string, handler HandlerFunc) <span class="cov8" title="1">{
        r.Handle(http.MethodPut, path, handler)
}</span>

// DELETE registers a new DELETE route
func (r *Router) DELETE(path string, handler HandlerFunc) <span class="cov8" title="1">{
        r.Handle(http.MethodDelete, path, handler)
}</span>

// SetNotFound sets the not found handler
func (r *Router) SetNotFound(handler HandlerFunc) <span class="cov8" title="1">{
        r.notFound = handler
}</span>

// SetMethodNotAllowed sets the method not allowed handler
func (r *Router) SetMethodNotAllowed(handler HandlerFunc) <span class="cov8" title="1">{
        r.methodNotAllowed = handler
}</span>

// pathMatch checks if the request path matches a route path
// and extracts path parameters
func pathMatch(routePath, requestPath string) (bool, map[string]string) <span class="cov8" title="1">{
        routeParts := strings.Split(routePath, "/")
        requestParts := strings.Split(requestPath, "/")

        if len(routeParts) != len(requestParts) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">params := make(map[string]string)

        for i, routePart := range routeParts </span><span class="cov8" title="1">{
                if len(routePart) &gt; 0 &amp;&amp; routePart[0] == ':' </span><span class="cov8" title="1">{
                        // This is a path parameter
                        paramName := routePart[1:]
                        params[paramName] = requestParts[i]
                }</span> else<span class="cov8" title="1"> if routePart != requestParts[i] </span><span class="cov8" title="1">{
                        // Not a parameter and doesnt match
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">return true, params</span>
}

// ServeHTTP implements the http.Handler interface
func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        // Find route
        var handler HandlerFunc
        var params map[string]string

        matchedRoutes := []Route{}

        for _, route := range r.routes </span><span class="cov8" title="1">{
                if match, pathParams := pathMatch(route.Path, req.URL.Path); match </span><span class="cov8" title="1">{
                        if route.Method == req.Method </span><span class="cov8" title="1">{
                                handler = route.Handler
                                params = pathParams
                                break</span>
                        } else<span class="cov8" title="1"> {
                                matchedRoutes = append(matchedRoutes, route)
                        }</span>
                }
        }

        // If no handler was found but we matched some routes with a different method,
        // its a method not allowed
        <span class="cov8" title="1">if handler == nil &amp;&amp; len(matchedRoutes) &gt; 0 </span><span class="cov8" title="1">{
                handler = r.methodNotAllowed
        }</span>

        // If no handler was found at all, use the not found handler
        <span class="cov8" title="1">if handler == nil </span><span class="cov8" title="1">{
                handler = r.notFound
        }</span>

        // Create context
        <span class="cov8" title="1">c := context.New(w, req)
        c.Params = params

        // Apply middlewares
        if len(r.middlewares) &gt; 0 </span><span class="cov8" title="1">{
                handler = Chain(r.middlewares...)(handler)
        }</span>

        // Execute handler
        <span class="cov8" title="1">handler(c)</span>
}

// Chain creates a chain of middleware
func Chain(middlewares ...Middleware) Middleware <span class="cov8" title="1">{
        return func(next HandlerFunc) HandlerFunc </span><span class="cov8" title="1">{
                for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        next = middlewares[i](next)
                }</span>
                <span class="cov8" title="1">return next</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package validator provides validation utilities for structs.
package validator

import (
        "fmt"
        "reflect"
        "regexp"
        "strings"
)

// ValidationError represents a validation error for a specific field
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// Validator validates structs based on validate tags
type Validator struct {
        errors []ValidationError
}

// New creates a new validator
func New() *Validator <span class="cov8" title="1">{
        return &amp;Validator{
                errors: []ValidationError{},
        }
}</span>

// Validate validates a struct using tags
func (v *Validator) Validate(obj any) []ValidationError <span class="cov8" title="1">{
        v.errors = []ValidationError{}
        v.validateStruct("", obj)
        return v.errors
}</span>

// HasErrors returns true if there are validation errors
func (v *Validator) HasErrors() bool <span class="cov8" title="1">{
        return len(v.errors) &gt; 0
}</span>

// validateStruct recursively validates a struct using validate tags
func (v *Validator) validateStruct(prefix string, obj any) <span class="cov8" title="1">{
        val := reflect.ValueOf(obj)

        if val.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                val = val.Elem()
        }</span>

        <span class="cov8" title="1">if val.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">typ := val.Type()

        for i := 0; i &lt; val.NumField(); i++ </span><span class="cov8" title="1">{
                field := val.Field(i)
                fieldType := typ.Field(i)

                if fieldType.Anonymous </span><span class="cov8" title="1">{
                        // Handle embedded struct
                        v.validateStruct(prefix, field.Interface())
                        continue</span>
                }

                // Get json tag name
                <span class="cov8" title="1">tag := fieldType.Tag.Get("json")
                if tag == "" || tag == "-" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Get the field name from tag
                <span class="cov8" title="1">fieldName := strings.Split(tag, ",")[0]
                if prefix != "" </span><span class="cov8" title="1">{
                        fieldName = prefix + "." + fieldName
                }</span>

                // Get validate tag
                <span class="cov8" title="1">validateTag := fieldType.Tag.Get("validate")
                if validateTag == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Nested struct validation
                <span class="cov8" title="1">if field.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                        v.validateStruct(fieldName, field.Interface())
                        continue</span>
                }

                // Slice validation for struct elements
                <span class="cov8" title="1">if field.Kind() == reflect.Slice &amp;&amp; field.Type().Elem().Kind() == reflect.Struct </span><span class="cov8" title="1">{
                        // Validate each item in the slice
                        for j := 0; j &lt; field.Len(); j++ </span><span class="cov8" title="1">{
                                item := field.Index(j)
                                itemFieldName := fmt.Sprintf("%s[%d]", fieldName, j)
                                v.validateStruct(itemFieldName, item.Interface())
                        }</span>
                }

                // Validate by rules
                <span class="cov8" title="1">rules := strings.Split(validateTag, ",")
                for _, rule := range rules </span><span class="cov8" title="1">{
                        v.validateField(field, fieldName, rule)
                }</span>
        }
}

// validateField validates a single field against a rule
func (v *Validator) validateField(field reflect.Value, fieldName, rule string) <span class="cov8" title="1">{
        // Parse rule and arguments
        parts := strings.SplitN(rule, "=", 2)
        ruleName := parts[0]

        var ruleArg string
        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                ruleArg = parts[1]
        }</span>

        // Apply the rule
        <span class="cov8" title="1">switch ruleName </span>{
        case "required":<span class="cov8" title="1">
                v.validateRequired(field, fieldName)</span>
        case "email":<span class="cov8" title="1">
                v.validateEmail(field, fieldName)</span>
        case "min":<span class="cov8" title="1">
                v.validateMin(field, fieldName, ruleArg)</span>
        case "max":<span class="cov8" title="1">
                v.validateMax(field, fieldName, ruleArg)</span>
        }
}

// validateRequired checks if a field is not empty
func (v *Validator) validateRequired(field reflect.Value, fieldName string) <span class="cov8" title="1">{
        isValid := true

        switch field.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                isValid = field.String() != ""</span>
        case reflect.Ptr, reflect.Slice, reflect.Map:<span class="cov8" title="1">
                isValid = !field.IsNil()</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                isValid = field.Int() != 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                isValid = field.Uint() != 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                isValid = field.Float() != 0</span>
        case reflect.Bool:<span class="cov8" title="1">
                isValid = field.Bool()</span>
        }

        <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                v.errors = append(v.errors, ValidationError{
                        Field:   fieldName,
                        Message: fieldName + " is required",
                })
        }</span>
}

// validateEmail checks if a field is a valid email
func (v *Validator) validateEmail(field reflect.Value, fieldName string) <span class="cov8" title="1">{
        if field.Kind() != reflect.String </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">email := field.String()
        if email == "" </span><span class="cov8" title="1">{
                return
        }</span>

        // Simple email validation regex
        <span class="cov8" title="1">emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
        if !emailRegex.MatchString(email) </span><span class="cov8" title="1">{
                v.errors = append(v.errors, ValidationError{
                        Field:   fieldName,
                        Message: fieldName + " must be a valid email address",
                })
        }</span>
}

// validateMin checks if a field meets a minimum constraint
func (v *Validator) validateMin(field reflect.Value, fieldName, arg string) <span class="cov8" title="1">{
        switch field.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                min := 0
                fmt.Sscanf(arg, "%d", &amp;min)
                if len(field.String()) &lt; min </span><span class="cov8" title="1">{
                        v.errors = append(v.errors, ValidationError{
                                Field:   fieldName,
                                Message: fmt.Sprintf("%s must be at least %d characters", fieldName, min),
                        })
                }</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                min := int64(0)
                fmt.Sscanf(arg, "%d", &amp;min)
                if field.Int() &lt; min </span><span class="cov8" title="1">{
                        v.errors = append(v.errors, ValidationError{
                                Field:   fieldName,
                                Message: fmt.Sprintf("%s must be at least %d", fieldName, min),
                        })
                }</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                min := float64(0)
                fmt.Sscanf(arg, "%f", &amp;min)
                if field.Float() &lt; min </span><span class="cov8" title="1">{
                        v.errors = append(v.errors, ValidationError{
                                Field:   fieldName,
                                Message: fmt.Sprintf("%s must be at least %f", fieldName, min),
                        })
                }</span>
        }
}

// validateMax checks if a field meets a maximum constraint
func (v *Validator) validateMax(field reflect.Value, fieldName, arg string) <span class="cov8" title="1">{
        switch field.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                max := 0
                fmt.Sscanf(arg, "%d", &amp;max)
                if len(field.String()) &gt; max </span><span class="cov8" title="1">{
                        v.errors = append(v.errors, ValidationError{
                                Field:   fieldName,
                                Message: fmt.Sprintf("%s must be at most %d characters", fieldName, max),
                        })
                }</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                max := int64(0)
                fmt.Sscanf(arg, "%d", &amp;max)
                if field.Int() &gt; max </span><span class="cov8" title="1">{
                        v.errors = append(v.errors, ValidationError{
                                Field:   fieldName,
                                Message: fmt.Sprintf("%s must be at most %d", fieldName, max),
                        })
                }</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                max := uint64(0)
                fmt.Sscanf(arg, "%d", &amp;max)
                if field.Uint() &gt; max </span><span class="cov8" title="1">{
                        v.errors = append(v.errors, ValidationError{
                                Field:   fieldName,
                                Message: fmt.Sprintf("%s must be at most %d", fieldName, max),
                        })
                }</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                max := float64(0)
                fmt.Sscanf(arg, "%f", &amp;max)
                if field.Float() &gt; max </span><span class="cov8" title="1">{
                        v.errors = append(v.errors, ValidationError{
                                Field:   fieldName,
                                Message: fmt.Sprintf("%s must be at most %f", fieldName, max),
                        })
                }</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
